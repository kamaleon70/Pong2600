
	processor 6502
        include "vcs.h"
        include "macro.h"
        include "xmacro.h"
        
SpriteHeight	equ 33        

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Variables segment

        seg.u Variables
	org $80

Temp		.byte
YPos1		.byte
YPos2		.byte
YPos1End	.byte
YPos2End	.byte
Score0	byte	; BCD score of player 0
Score1	byte	; BCD score of player 1
FontBuf	ds 10	; 2x5 array of playfield bytes
CountMidLine	.byte
MidLineEnabled	.byte
BallPosX	.byte
BallPosY	.byte
PreviousBall	.byte
BallDirectionX	.byte
BallDirectionY	.byte

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Code segment

	seg Code
        org $f000


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Start and Initialization
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Start
	CLEAN_START
        lda #80
        sta YPos1
        lda #80+32
        sta YPos1End
        lda #2
        sta YPos2  
        lda #2+32
        sta YPos2End
        
        sta WSYNC
        SLEEP 21
        sta RESP0
        
        SLEEP 21
        sta RESM0
        
        SLEEP 18
        sta RESP1
        
        lda #0
        sta PreviousBall
        
        lda #$0E
        sta COLUP0
        sta COLUP1
        
        lda #%00010000
        sta NUSIZ0
        
        lda #0
        sta CountMidLine
        sta BallDirectionX
        sta BallDirectionY
        lda #5
        sta BallPosX

        sta MidLineEnabled

	; For Missile 0 used to draw middle line
        lda #$10
        sta HMM0
        sta WSYNC
        sta HMOVE
        
        lda #140
        sta BallPosY
        
        lda #%00000010
        sta ENABL
        
        lda #4
        sta AUDC0
        lda #5
        sta AUDF0
 
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Game Loop
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
NextFrame
        lsr SWCHB	; test Game Reset switch
        bcc Start	; reset?

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 1 + 3 lines of VSYNC
	VERTICAL_SYNC
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        
; 37 lines of underscan
	TIMER_SETUP 37
        
        lda #0
        sta AUDV0
        
        lda #%0000001
	sta CTRLPF
        
        lda #$C2
        sta COLUPF
        
        lda Score0
        ldx #0
	jsr GetBCDBitmap
	lda Score1
        ldx #5
	jsr GetBCDBitmap
        
        lda BallDirectionX
        bne DecX
        
        inc BallPosX
        jmp XDirection
DecX
	dec BallPosX
XDirection
        lda BallPosX
        ldx #4
        jsr SetHorizPos
       	sta WSYNC
        sta HMOVE
        
        lda #%00000000
        sta ENABL   
        
        lda BallPosX
        cmp #$9E
        bne NoExitBall
        lda #3
        sta BallPosX
NoExitBall


        lda BallDirectionY
        bne DecY
	inc BallPosY
        jmp YDirection
DecY
	dec BallPosY
YDirection

	TIMER_WAIT
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        
; 192 lines of frame

; First part playfield


; First, we'll draw the scoreboard.
; Put the playfield into score mode (bit 2) which gives
; two different colors for the left/right side of
; the playfield (given by COLUP0 and COLUP1).

; Now we draw all four digits.

        

        lda #%0000001
	sta CTRLPF

	lda #%11111111        
        sta PF1
        sta PF2
        
       	lda #%11001111
        sta PF0   
        sta WSYNC        
       	lda #%11101111
        sta PF0   
        sta WSYNC        

	lda #%11111111        
        sta PF0
        
        REPEAT 4
          sta WSYNC
	REPEND
      
        ldy #0		; Y will contain the frame Y coordinate
        sty PF0
        sty PF1
        sty PF2
        lda #%00010010	; score mode + 2 pixel ball
        sta CTRLPF
        lda #$48
        sta COLUP0	; set color for left
        lda #$a8
        sta COLUP1	; set color for right        
        sta WSYNC
ScanLoop1a
	sta WSYNC
        tya
        lsr		; divide Y by two for double-height lines
        tax		; -> X
        lda FontBuf+0,x
        sta PF1		; set left score bitmap
        SLEEP 24
        lda FontBuf+5,x
        sta PF1		; set right score bitmap
        iny
        cpy #10
        bcc ScanLoop1a

        
	TIMER_SETUP 9
     
        lda #0		; Y will contain the frame Y coordinate
        sta PF0
        sta PF1
        sta PF2
        
        sta WSYNC
        sta WSYNC
        
        lda #%00010001
	sta CTRLPF        
	lda #$C2
        sta COLUPF
	lda #%11111111
        sta PF0
        sta PF1
        sta PF2

        TIMER_WAIT
        

; Section game field
        ldx #160-4

        lda #$0E
        sta COLUPF
        
        lda #0
        sta PF1
	lda #%00010000        
        sta PF0        
        lda #%10000000
        sta PF2
        sta WSYNC
Loop

; Draw ball

	cpx BallPosY
        bne NoBall
        lda #%00000010
        sta ENABL
        lda #3
        sta PreviousBall
        jmp Ball
NoBall
	lda PreviousBall
        beq NextBall
        dec PreviousBall
        jmp Ball
NextBall        
	lda #0
        sta ENABL
Ball


; Draw Sprites

	txa		; X -> A
        sec		; set carry for subtract
        sbc YPos1	; local coordinate
        cmp #SpriteHeight ; in sprite?
        bcc InSprite	; yes, skip over next
        lda #0		; not in sprite, load 0
InSprite
	tay		; local coord -> Y
        lda PlayerSprite,y	; lookup frame data
        sta GRP0	; store bitmap


	txa		; X -> A
        sec		; set carry for subtract
        sbc YPos2	; local coordinate
        cmp #SpriteHeight ; in sprite?
        bcc InSprite2	; yes, skip over next
        lda #0		; not in sprite, load 0
InSprite2
	tay		; local coord -> Y
        lda PlayerSprite,y	; lookup frame data
        sta GRP1	; store bitmap


	dex
	STA WSYNC
        bne Loop


; Lower part of the playfield
	lda #$C2
        sta COLUPF
        
       	lda #%11111111
        sta PF1
        sta PF0        
        sta PF2

	REPEAT 5
          sta WSYNC
        REPEND
        
       	lda #%11101111
        sta PF0   
        sta WSYNC
       	lda #%11001111
        sta PF0   
        sta WSYNC
        

; Clear playfield
	lda #0
        sta PF0
        sta PF1
        sta PF2  
        
        sta WSYNC
        sta WSYNC
        
        
; 29 lines of overscan
	TIMER_SETUP 29
        
        
; Handles players movement        

        lda SWCHA
        and #%00010000
        bne NoMov
        inc YPos1
        inc YPos1
        inc YPos1End
        inc YPos1End
NoMov
	lda SWCHA
        and #%00100000
        bne NoMov2
        dec YPos1
        dec YPos1
        dec YPos1End
        dec YPos1End     
NoMov2

        lda SWCHA
        and #%00000001
        bne NoMov3
        inc YPos2
        inc YPos2
        inc YPos2End
        inc YPos2End     
NoMov3

	lda SWCHA
        and #%00000010
        bne NoMov4
        dec YPos2
        dec YPos2
        dec YPos2End
        dec YPos2End        
NoMov4

; Verifies that players do not move outside the limits
	lda YPos2
        bne OK
  	lda #2
        sta YPos2
        clc
        adc #32
        sta YPos2End        
OK


	lda YPos1
        bne OK2
  	lda #2
        sta YPos1
        clc
        adc #32
        sta YPos1End 
OK2
      
      
      	lda YPos2End
        cmp #$A2
        bmi OK3
  	lda #$A0
        sta YPos2End
        lda #$80
        sta YPos2         
OK3

      	lda YPos1End
        cmp #$A2
        bmi OK4
  	lda #$A0
        sta YPos1End
        lda #$80
        sta YPos1 
OK4


	bit CXP1FB
        bvc NoHitPlayer1
        lda BallDirectionX
        eor #%00000001
        sta BallDirectionX
        lda #6
        sta AUDV0
NoHitPlayer1    

	bit CXP0FB
        bvc NoHitPlayer0
        lda BallDirectionX
        eor #%00000001
        sta BallDirectionX
        lda #6
        sta AUDV0
NoHitPlayer0  

	lda BallPosY
        cmp #160
        bne NoHitTopWall
        lda BallDirectionY
        eor #%00000001
        sta BallDirectionY
        lda #6
        sta AUDV0
NoHitTopWall

	lda BallPosY
        cmp #6
        bne NoHitBottomWall
        lda BallDirectionY
        eor #%00000001
        sta BallDirectionY
        lda #6
        sta AUDV0
NoHitBottomWall

	sed
	lda BallPosX
        cmp #$9D
        bne NoHitRightWall
        lda #100
        sta BallPosX
        lda BallDirectionX
        eor #%00000001
        sta BallDirectionX        
        clc
        lda Score0
        adc #1
        sta Score0
NoHitRightWall

	lda BallPosX
        cmp #4
        bne NoHitLeftWall
        lda #50
	sta BallPosX        
        lda BallDirectionX
        eor #%00000001
        sta BallDirectionX        
        clc
        lda Score1
        adc #1
        sta Score1
NoHitLeftWall
	cld

        sta CXCLR
        TIMER_WAIT
        
; total = 262 lines, go to next frame
        jmp NextFrame


; Fetches bitmap data for two digits of a
; BCD-encoded number, storing it in addresses
; FontBuf+x to FontBuf+4+x.
GetBCDBitmap subroutine
; First fetch the bytes for the 1st digit
	pha		; save original BCD number
        and #$0F	; mask out the least significant digit
        sta Temp
        asl
        asl
        adc Temp	; multiply by 5
        tay		; -> Y
        lda #5
        sta Temp	; count down from 5
.loop1
        lda DigitsBitmap,y
        and #$0F	; mask out leftmost digit
        sta FontBuf,x	; store leftmost digit
        iny
        inx
        dec Temp
        bne .loop1
; Now do the 2nd digit
        pla		; restore original BCD number
        lsr
        lsr
        lsr
        lsr		; shift right by 4 (in BCD, divide by 10)
        sta Temp
        asl
        asl
        adc Temp	; multiply by 5
        tay		; -> Y
        dex
        dex
        dex
        dex
        dex		; subtract 5 from X (reset to original)
        lda #5
        sta Temp	; count down from 5
.loop2
        lda DigitsBitmap,y
        and #$F0	; mask out leftmost digit
        ora FontBuf,x	; combine left and right digits
        sta FontBuf,x	; store combined digits
        iny
        inx
        dec Temp
        bne .loop2
	rts

	org $FF00

; Bitmap pattern for digits
DigitsBitmap ;;{w:8,h:5,count:10,brev:1};;
        .byte $EE,$AA,$AA,$AA,$EE
        .byte $22,$22,$22,$22,$22
        .byte $EE,$22,$EE,$88,$EE
        .byte $EE,$22,$66,$22,$EE
        .byte $AA,$AA,$EE,$22,$22
        .byte $EE,$88,$EE,$22,$EE
        .byte $EE,$88,$EE,$AA,$EE
        .byte $EE,$22,$22,$22,$22
        .byte $EE,$AA,$EE,$AA,$EE
        .byte $EE,$AA,$EE,$22,$EE
        
;---Graphics Data from PlayerPal 2600---

; Player graphics data
PlayerSprite
        .byte #%00000000;--
        .byte #%00011000;--
        .byte #%00111100;--
        .byte #%00111100;--
        .byte #%01111110;--
        .byte #%01111110;--
        .byte #%01111110;--
        .byte #%01111110;--
        .byte #%01111110;--
        .byte #%01111110;--
        .byte #%01111110;--   
        .byte #%01111110;--
        .byte #%01111110;--
        .byte #%01111110;--
        .byte #%01111110;--
        .byte #%01111110;--
        .byte #%01111110;--      
        .byte #%01111110;--
        .byte #%01111110;--
        .byte #%01111110;--
        .byte #%01111110;--
        .byte #%01111110;--
        .byte #%01111110;--
        .byte #%01111110;--
        .byte #%01111110;--
        .byte #%01111110;--
        .byte #%01111110;--
        .byte #%01111110;--
        .byte #%01111110;--
        .byte #%01111110;--
        .byte #%00111100;--
        .byte #%00111100;--
        .byte #%00011000;--
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SetHorizPos routine
; A = X coordinate
; X = player number (0 or 1)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; After this subroutine it is necessary to use
;
; 	sta WSYNC
; 	sta HMOVE
;
; to correctly set the parameters
; Then better to set (after waitin 26 cpu cycles)
;
; 	sta HMCLR
;
; so next sta HMOVE will not impact the position

; Everything should be in the same page
; otherwise the timing is not correct

; The entire routine is positioned in memory at the end just to
; assure that the branch is not moving to a different page
; Total size of the routine 18 bytes.

SetHorizPos SUBROUTINE
	sec		; set carry flag
	sta WSYNC	; start a new line
.DivideLoop
	sbc #15		; subtract 15
	bcs .DivideLoop	; branch until negative
	eor #7		; calculate fine offset
        asl
        asl
        asl
        asl
	sta HMP0,x	; set fine offset
	sta RESP0,x	; fix coarse position
	rts		; return to caller        

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Epilogue
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	org $fffc
        .word Start	; reset vector
        .word Start	; BRK vector
