
	processor 6502
        include "vcs.h"
        include "macro.h"
        include "xmacro.h"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Variables segment

        seg.u Variables
	org $80

Temp		.byte
YPos1		.byte
YPos2		.byte
YPos1End	.byte
YPos2End	.byte
Score0	byte	; BCD score of player 0
Score1	byte	; BCD score of player 1
FontBuf	ds 10	; 2x5 array of playfield bytes

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Code segment

	seg Code
        org $f000


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Start and Initialization
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Start
	CLEAN_START
        lda #80
        sta YPos1
        lda #80+32
        sta YPos1End
        lda #2
        sta YPos2  
        lda #2+32
        sta YPos2End
        
        sta WSYNC
        SLEEP 21
        sta RESP0
        
        SLEEP 21
        sta RESM0
        
        SLEEP 18
        sta RESP1        
        
        lda #$0E
        sta COLUP0
        sta COLUP1
        
        lda #%00010000
        sta NUSIZ0

	; For Missile 0 used to draw middle line
        lda #$10
        sta HMM0
        sta WSYNC
        sta HMOVE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Game Loop
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
NextFrame
        lsr SWCHB	; test Game Reset switch
        bcc Start	; reset?

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 1 + 3 lines of VSYNC
	VERTICAL_SYNC
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        
; 37 lines of underscan
	TIMER_SETUP 37
        
        lda #%0000001
	sta CTRLPF
        
        lda Score0
        ldx #0
	jsr GetBCDBitmap
	lda Score1
        ldx #5
	jsr GetBCDBitmap

	TIMER_WAIT
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        
; 192 lines of frame

; First part playfield


; First, we'll draw the scoreboard.
; Put the playfield into score mode (bit 2) which gives
; two different colors for the left/right side of
; the playfield (given by COLUP0 and COLUP1).

; Now we draw all four digits.

        
	TIMER_SETUP 5
        lda #%0000001
	sta CTRLPF
	lda #$0E
        sta COLUPF
	lda #%11111111        
        sta PF0
        sta PF1
        sta PF2
        TIMER_WAIT
        
        ldy #0		; Y will contain the frame Y coordinate
        sta PF0
        sta PF1
        sta PF2
        lda #%00010010	; score mode + 2 pixel ball
        sta CTRLPF
        lda #$48
        sta COLUP0	; set color for left
        lda #$a8
        sta COLUP1	; set color for right        
ScanLoop1a
	sta WSYNC
        tya
        lsr		; divide Y by two for double-height lines
        tax		; -> X
        lda FontBuf+0,x
        sta PF1		; set left score bitmap
        SLEEP 28
        lda FontBuf+5,x
        sta PF1		; set right score bitmap
        iny
        cpy #10
        bcc ScanLoop1a

        
	TIMER_SETUP 10
        lda #0		; Y will contain the frame Y coordinate
        sta PF0
        sta PF1
        sta PF2
        
        sta WSYNC
        sta WSYNC
        
        lda #%0000001
	sta CTRLPF        
	lda #$0E
        sta COLUPF
	lda #%11111111
        sta PF0
        sta PF1
        sta PF2

	REPEAT 4
          sta WSYNC
        REPEND

	lda #0
        sta PF1
        sta PF2        
	lda #$04
        sta COLUPF        
	lda #%00010000        
        sta PF0        
        TIMER_WAIT
        

; Section game field
        ldx #(142+9+3)
	TIMER_SETUP 142+9+5
        
Loop

; Draw sprites

        cpx YPos1
        bne NotBeginSprite
        lda #0
        sta GRP0
        jmp SpriteCompleted
NotBeginSprite
	cpx YPos1End
        bne SpriteCompleted
        lda #%00111100
        sta GRP0
SpriteCompleted  


        cpx YPos2
        bne NotBeginSprite2
        lda #0
        sta GRP1
        jmp SpriteCompleted2
NotBeginSprite2
	cpx YPos2End
        bne SpriteCompleted2
        lda #%01111000
        sta GRP1
SpriteCompleted2  


        sta WSYNC
        dex
        bne Loop
        TIMER_WAIT


; Close playfield
	TIMER_SETUP 5

	lda #$0E
        sta COLUPF
	lda #%11111111
        sta PF0
        sta PF1
        sta PF2
        
	REPEAT 4
          sta WSYNC
        REPEND

	; Disable missile 0
	lda #%00000000
        sta ENAM0

	lda #0
        sta PF0
        sta PF1
        sta PF2        
        
        
; 29 lines of overscan
	TIMER_SETUP 29
        
        
; Handles players movement        

        lda SWCHA
        and #%00010000
        bne NoMov
        inc YPos1
        inc YPos1
        inc YPos1End
        inc YPos1End
NoMov
	lda SWCHA
        and #%00100000
        bne NoMov2
        dec YPos1
        dec YPos1
        dec YPos1End
        dec YPos1End     
NoMov2

        lda SWCHA
        and #%00000001
        bne NoMov3
        inc YPos2
        inc YPos2
        inc YPos2End
        inc YPos2End     
NoMov3

	lda SWCHA
        and #%00000010
        bne NoMov4
        dec YPos2
        dec YPos2
        dec YPos2End
        dec YPos2End        
NoMov4

; Verifies that players do not move outside the limits
	lda YPos2
        bne OK
  	lda #2
        sta YPos2
        clc
        adc #32
        sta YPos2End        
OK


	lda YPos1
        bne OK2
  	lda #2
        sta YPos1
        clc
        adc #32
        sta YPos1End 
OK2
      
      
      	lda YPos2End
        cmp #$9A
        bmi OK3
  	lda #$98
        sta YPos2End
        lda #$78
        sta YPos2         
OK3

      	lda YPos1End
        cmp #$9A
        bmi OK4
  	lda #$98
        sta YPos1End
        lda #$78
        sta YPos1 
OK4
      
        TIMER_WAIT
        
; total = 262 lines, go to next frame
        jmp NextFrame


; Fetches bitmap data for two digits of a
; BCD-encoded number, storing it in addresses
; FontBuf+x to FontBuf+4+x.
GetBCDBitmap subroutine
; First fetch the bytes for the 1st digit
	pha		; save original BCD number
        and #$0F	; mask out the least significant digit
        sta Temp
        asl
        asl
        adc Temp	; multiply by 5
        tay		; -> Y
        lda #5
        sta Temp	; count down from 5
.loop1
        lda DigitsBitmap,y
        and #$0F	; mask out leftmost digit
        sta FontBuf,x	; store leftmost digit
        iny
        inx
        dec Temp
        bne .loop1
; Now do the 2nd digit
        pla		; restore original BCD number
        lsr
        lsr
        lsr
        lsr		; shift right by 4 (in BCD, divide by 10)
        sta Temp
        asl
        asl
        adc Temp	; multiply by 5
        tay		; -> Y
        dex
        dex
        dex
        dex
        dex		; subtract 5 from X (reset to original)
        lda #5
        sta Temp	; count down from 5
.loop2
        lda DigitsBitmap,y
        and #$F0	; mask out leftmost digit
        ora FontBuf,x	; combine left and right digits
        sta FontBuf,x	; store combined digits
        iny
        inx
        dec Temp
        bne .loop2
	rts

	org $FF00

; Bitmap pattern for digits
DigitsBitmap ;;{w:8,h:5,count:10,brev:1};;
        .byte $EE,$AA,$AA,$AA,$EE
        .byte $22,$22,$22,$22,$22
        .byte $EE,$22,$EE,$88,$EE
        .byte $EE,$22,$66,$22,$EE
        .byte $AA,$AA,$EE,$22,$22
        .byte $EE,$88,$EE,$22,$EE
        .byte $EE,$88,$EE,$AA,$EE
        .byte $EE,$22,$22,$22,$22
        .byte $EE,$AA,$EE,$AA,$EE
        .byte $EE,$AA,$EE,$22,$EE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Epilogue
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	org $fffc
        .word Start	; reset vector
        .word Start	; BRK vector
